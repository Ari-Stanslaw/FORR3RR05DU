Verkefni 2.1
Naive reiknirit er yfirleitt augljósasta lausnin þegar maður er spurður um vandamál. Það gæti ekki verið klár reiknirit en mun líklega fá vinnu 

RUSSIAN er áhugaverð leið til að margfalda tölur sem nota ferli við helming og tvöföldun. Eins og venjulegur margföldun og skipting er RUSSIAN margföldun algorithm, hins vegar leyfir þú þér að margfalda tvær tvær heilar tölur með því að nota aðeins margföldun og skiptingu með 2.

russian er hraðvirkari því hann lætur tölvuna reikna mun minna með að deila það í helming hvert skipti en ekki alltaf bara mínus 1 eins og native

Verkefni 2.2
a)
public class QuickFind
{
  private int[] id;
  
  public QuickFind(int N)
  {
  id = new int[N];
    for (int i = 0; i < N; i++)
    {
    id[i] = i;
    }
  }
  
  public bool connected(int p, int q)
  {
    return id[p] == id[q];
  }
  
  public void union(int p, int q)
  {
    int pid = id[p];
    int qid = id[q];
    for(int i = 0; i < id.length; i++)
    {
      if(id[i] == pid)
      {
       id[i] = qid;
      }
    }
  }
}

public class QuickUnion
{
  private int[] id;
  
  public QuickUnion(int N)
  {
    id = new int[N];
    for(int i = 0; i < N; i++)
    {
      id[i] = i;
    }
    
    private int root(int i)
    {
      while(i != id[i])
      {
        i = id[i];
        return i
      }
    }
    
    public bool connected(int p, int q)
    {
      return root(p) == root(q);
    }
    
    public void union(int p, int q)
    {
      int i = root(p);
      int j = root(q);
      id[i] = j;
    }
  }
}


public class QuickUnionImproved
{
  private int[] id;
  
  public QuickUnionImproved(int N)
  {
    id = new int[N];
    for(int i = 0; i < N; i++)
    {
      id[i] = i;
    }
    
    private int root(int i)
    {
      while(i != id[i])
      {
        id[i] = id[id[i]];
        i = id[i];
      }
      return i
    }
    
    public bool connected(int p, int q)
    {
      return root(p) == root(q);
    }
    
    public void union(int p, int q)
    {
      int i = root(p);
      int j = root(q);
      if (i == j)
      {
        return;
      }
      if (sz[i] < sz[j]) 
      {
      id[i] = j; sz[j] += sz[i];
      }
      else
      {
      id[j] = i; sz[i] += sz[j]; 
      }
    }
  }
}

public class WeightedQU 
{
    private int[] id;
    private int[] iz;

    public WeightedQU(int N)
    {
        id = new int[N];
        iz = new int[N];
        for(int i = 0; i < id.length; i++)
        {
            iz[i] = i;
            id[i] = i;
        }
    }

    public int root(int i)
    {
        while(i != id[i])
        {
            id[i] = id[id[i]];   // this line represents "path compression"
            i = id[i];
        }
        return i;
    }

    public bool connected(int p, int q)
    {
        return root(p) == root(q);
    }

    public void union(int p, int q)   // here iz[] is used to "weighting"
    {
        int i = root(p);
        int j = root(q);
        if(iz[i] < iz[j])
        {
            id[i] = j;
            iz[j] += iz[i];
        }
        else
        {
            id[j] = i;
            iz[i] += iz[j];
        }
    }
}

sleppa e)
